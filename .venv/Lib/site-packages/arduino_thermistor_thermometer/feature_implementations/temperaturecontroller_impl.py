# Generated by sila2.code_generator; sila2.__version__: 0.12.2
from __future__ import annotations

from datetime import datetime, timedelta
from typing import TYPE_CHECKING
import logging


from sila2.server import MetadataDict, ObservableCommandInstance

from ..generated.temperaturecontroller import ControlTemperature_Responses, TemperatureControllerBase
from .temperature_metadata_model import jsonld_context

if TYPE_CHECKING:
    from ..server import Server

logger = logging.getLogger(__name__)

class TemperatureControllerImpl(TemperatureControllerBase):
    def __init__(self, parent_server: Server) -> None:
        super().__init__(parent_server=parent_server)

        self.hwif = parent_server.hardware_interface

        # Default lifetime of observable command instances. Possible values:
        # None: Command instance is valid and stored in memory until server shutdown
        # datetime.timedelta: Command instance is deleted after this duration, can be increased during command runtime
        self.ControlTemperature_default_lifetime_of_execution = timedelta(minutes=30)

        self.run_periodically(self._keep_temperature_up_to_date, delay_seconds=5)

        # TODO: fill this using DeviceInfo provider, and Pydantic Settings
        self.metadata_json = """
{
  "id": "1234",
  "users": [{"name_first":"Alice","name_last": "Albatros", "orcid":"0000-0001-2345-6789"},  
         {"name_first":"Bob","name_last": "Baker", "orcid":"0000-0001-2345-6790"}],
  "method": "oso:measurement/temperature",
  "timestamp": "2021-01-01T00:00:00Z",
  "procedure_name": "temperature_measurement",
  "session_name": "temperature_measurement_session_1",
  "software": "Arduino_SiLA_temperature_controller",
  "software_version": "0.0.1",
  "environment_temperature": 301.0,
  "environment_air_humidity": 0.5,
  "environment_air_pressure": 1013,
  "geolocation": "54.088,13.3833",
  "altitude": 5,
  "device_type": "thermometer",
  "device_serial": "234024",
  "device_version": "1.0",
  "device_name": "Teensy Arduino Thermistor",
  "device_model_name": "Thermistor T1",
  "device_manufacturer_name": "PJRC",
  "checksum_previous": "BD94760347BABBB0B12ADFEB41FF01B90DD7F4C16F9B6C2088CD2526F6223898"
}

"""

    def get_Metadata(self, *, metadata: MetadataDict) -> str:
        return self.metadata_json
    
    def _keep_temperature_up_to_date(self):
        try:
            # random temperature for testing (float between 0 and 100)
            
            curr_t, target_t = (self.hwif.current_temperature, 66.6) #self.com.temperature
            self.current_temperature = curr_t
            print(f"**** updating temperature - curr: {curr_t}  target: {target_t}\n")
            self.update_CurrentTemperature(curr_t)

            # JSON-LD


            # use the metadata_model jsonld_context from the metadata model
            curr_t_jsonld = {
                "@context": "oso:temperature-control",
                "@type": "Temperature",
                "timestamp": datetime.now().isoformat(),
                "temperature": curr_t,
                "temperature_target": target_t,
            }
            self.update_CurrentTemperatureJSONLD(str(curr_t_jsonld))
            
        except Exception as ex:
            logging.warning(
                f"Temperature update for thermometer failed: {ex} {traceback.print_exc()}"
            )
            pass

    def ControlTemperature(
        self, TargetTemperature: float, *, metadata: MetadataDict, instance: ObservableCommandInstance
    ) -> ControlTemperature_Responses:
        # set execution status from `waiting` to `running`
        instance.begin_execution()

        raise NotImplementedError  # TODO
